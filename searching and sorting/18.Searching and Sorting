# Assignment Questions 18

<aside>
ğŸ’¡ 1. **Merge Intervals**

Given an arrayÂ ofÂ `intervals`Â whereÂ `intervals[i] = [starti, endi]`, merge all overlapping intervals, and returnÂ *an array of the non-overlapping intervals that cover all the intervals in the input*.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

```

**Constraints:**

- `1 <= intervals.length <= 10000`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 10000`
</aside>

<aside>
ğŸ’¡ 2. **Sort Colors**

Given an arrayÂ `nums`Â withÂ `n`Â objects colored red, white, or blue, sort themÂ **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**Â so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integersÂ `0`,Â `1`, andÂ `2`Â to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

**Example 1:**

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

```

**Example 2:**

```
Input: nums = [2,0,1]
Output: [0,1,2]

```

**Constraints:**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]`Â is eitherÂ `0`,Â `1`, orÂ `2`.
</aside>

<aside>
ğŸ’¡ 3. **First Bad Version Solution**

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you haveÂ `n`Â versionsÂ `[1, 2, ..., n]`Â and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an APIÂ `bool isBadVersion(version)`Â which returns whetherÂ `version`Â is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

**Example 1:**

```
Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5)Â -> true
call isBadVersion(4)Â -> true
Then 4 is the first bad version.

```

**Example 2:**

```
Input: n = 1, bad = 1
Output: 1

```

**Constraints:**

- `1 <= bad <= n <= 2^31Â - 1`
</aside>

<aside>
ğŸ’¡ 4. **Maximum Gap**

Given an integer arrayÂ `nums`, returnÂ *the maximum difference between two successive elements in its sorted form*. If the array contains less than two elements, returnÂ `0`.

You must write an algorithm that runs in linear time and uses linear extra space.

**Example 1:**

```
Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.

```

**Example 2:**

```
Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.

```

**Constraints:**

- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 10^9`
</aside>

<aside>
ğŸ’¡ 5. **Contains Duplicate**

Given an integer arrayÂ `nums`, returnÂ `true`Â if any value appearsÂ **at least twice**Â in the array, and returnÂ `false`Â if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true

```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false

```

**Example 3:**

```
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

```

**Constraints:**

- `1 <= nums.length <= 10^5`
- `109 <= nums[i] <= 10^9`
</aside>

<aside>
ğŸ’¡ 6. **Minimum Number of Arrows to Burst Balloons**

There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer arrayÂ `points`Â whereÂ `points[i] = [xstart, xend]`Â denotes a balloon whoseÂ **horizontal diameter**Â stretches betweenÂ `xstart`Â andÂ `xend`. You do not know the exact y-coordinates of the balloons.

Arrows can be shot upÂ **directly vertically**Â (in the positive y-direction) from different points along the x-axis. A balloon withÂ `xstart`Â andÂ `xend`Â isÂ **burst**Â by an arrow shot atÂ `x`Â ifÂ `xstart <= x <= xend`. There isÂ **no limit**Â to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the arrayÂ `points`, returnÂ *theÂ **minimum**Â number of arrows that must be shot to burst all balloons*.

**Example 1:**

```
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].

```

**Example 2:**

```
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.

```

**Example 3:**

```
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].

```

**Constraints:**

- `1 <= points.length <= 10^5`
- `points[i].length == 2`
- `231 <= xstart < xend <= 2^31 - 1`
</aside>

<aside>
ğŸ’¡ 7. **Longest Increasing Subsequence**

Given an integer arrayÂ `nums`, returnÂ *the length of the longestÂ **strictly increasing***

***subsequence***

.

**Example 1:**

```
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.

```

**Example 2:**

```
Input: nums = [0,1,0,3,2,3]
Output: 4

```

**Example 3:**

```
Input: nums = [7,7,7,7,7,7,7]
Output: 1

```

**Constraints:**

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`
</aside>

<aside>
ğŸ’¡ 8. **132 Pattern**

Given an array ofÂ `n`Â integersÂ `nums`, aÂ **132 pattern**Â is a subsequence of three integersÂ `nums[i]`,Â `nums[j]`Â andÂ `nums[k]`Â such thatÂ `i < j < k`Â andÂ `nums[i] < nums[k] < nums[j]`.

ReturnÂ `true`Â *if there is aÂ **132 pattern**Â in*Â `nums`*, otherwise, return*Â `false`*.*

**Example 1:**

```
Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.

```

**Example 2:**

```
Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

```

**Example 3:**

```
Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].

```

**Constraints:**

- `n == nums.length`
- `1 <= n <= 2 * 10^5`
- `-10^9 <= nums[i] <= 10^9`

</aside>
# Assignment Questions 19

<aside>
ğŸ’¡ 1. **Merge k Sorted Lists**

You are given an array ofÂ `k`Â linked-listsÂ `lists`, each linked-list is sorted in ascending order.

*Merge all the linked-lists into one sorted linked-list and return it.*

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

```

**Example 2:**

```
Input: lists = []
Output: []

```

**Example 3:**

```
Input: lists = [[]]
Output: []

```

**Constraints:**

- `k == lists.length`
- `0 <= k <= 10000`
- `0 <= lists[i].length <= 500`
- `-10000 <= lists[i][j] <= 10000`
- `lists[i]`Â is sorted inÂ **ascending order**.
- The sum ofÂ `lists[i].length`Â will not exceedÂ `10000`.
</aside>

<aside>
ğŸ’¡ 2. **Count of Smaller Numbers After Self**

Given an integer arrayÂ `nums`, returnÂ *an integer array*Â `counts`Â *where*Â `counts[i]`Â *is the number of smaller elements to the right of*Â `nums[i]`.

**Example 1:**

```
Input: nums = [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are2 smaller elements (2 and 1).
To the right of 2 there is only1 smaller element (1).
To the right of 6 there is1 smaller element (1).
To the right of 1 there is0 smaller element.

```

**Example 2:**

```
Input: nums = [-1]
Output: [0]

```

**Example 3:**

```
Input: nums = [-1,-1]
Output: [0,0]

```

**Constraints:**

- `1 <= nums.length <= 100000`
- `-10000 <= nums[i] <= 10000`
</aside>

<aside>
ğŸ’¡ 3. **Sort an Array**

Given an array of integersÂ `nums`, sort the array in ascending order and return it.

You must solve the problemÂ **without using any built-in**Â functions inÂ `O(nlog(n))`Â time complexity and with the smallest space complexity possible.

**Example 1:**

```
Input: nums = [5,2,3,1]
Output: [1,2,3,5]
Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).

```

**Example 2:**

```
Input: nums = [5,1,1,2,0,0]
Output: [0,0,1,1,2,5]
Explanation: Note that the values of nums are not necessairly unique.

```

**Constraints:**

- `1 <= nums.length <= 5 * 10000`
- `-5 * 104 <= nums[i] <= 5 * 10000`
</aside>

<aside>
ğŸ’¡ 4. **Move all zeroes to end of array**

Given an array of random numbers, Push all the zeroâ€™s of a given array to the end of the array. For example, if the given arrays is {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}, it should be changed to {1, 9, 8, 4, 2, 7, 6, 0, 0, 0, 0}. The order of all other elements should be same. Expected time complexity is O(n) and extra space is O(1).

**Example:**

```
Input :  arr[] = {1, 2, 0, 4, 3, 0, 5, 0};
Output : arr[] = {1, 2, 4, 3, 5, 0, 0, 0};

Input : arr[]  = {1, 2, 0, 0, 0, 3, 6};
Output : arr[] = {1, 2, 3, 6, 0, 0, 0};
```

</aside>

<aside>
ğŸ’¡ 5. **Rearrange array in alternating positive & negative items with O(1) extra space**

Given anÂ **array of positive**Â andÂ **negative numbers**, arrange them in anÂ **alternate**Â fashion such that every positive number is followed by a negative and vice-versa maintaining theÂ **order of appearance**.Â The number of positive and negative numbers need not be equal. If there are more positive numbers they appear at the end of the array. If there are more negative numbers, they too appear at the end of the array.

**Examples:**

> Input: Â arr[] = {1, 2, 3, -4, -1, 4}
Output: arr[] = {-4, 1, -1, 2, 3, 4}

Input: Â arr[] = {-5, -2, 5, 2, 4, 7, 1, 8, 0, -8}
Output: arr[] = {-5, 5, -2, 2, -8, 4, 7, 1, 8, 0}
> 
</aside>

<aside>
ğŸ’¡ **6. Merge two sorted arrays**

Given two sorted arrays, the task is to merge them in a sorted manner.

**Examples:**

> Input: arr1[] = { 1, 3, 4, 5}, arr2[] = {2, 4, 6, 8}Â 
Output: arr3[] = {1, 2, 3, 4, 4, 5, 6, 8}

Input: arr1[] = { 5, 8, 9}, arr2[] = {4, 7, 8}
Output: arr3[] = {4, 5, 7, 8, 8, 9}
> 
</aside>

<aside>
ğŸ’¡ 7. **Intersection of Two Arrays**

Given two integer arraysÂ `nums1`Â andÂ `nums2`, returnÂ *an array of their intersection*. Each element in the result must beÂ **unique**Â and you may return the result inÂ **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.

```

**Constraints:**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`
</aside>

<aside>
ğŸ’¡ 8. **Intersection of Two Arrays II**

Given two integer arraysÂ `nums1`Â andÂ `nums2`, returnÂ *an array of their intersection*. Each element in the result must appear as many times as it shows in both arrays and you may return the result inÂ **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]

```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.

```

**Constraints:**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`
</aside>
# Assignment Questions 11

<aside>
ğŸ’¡ **Question 1**

Given a non-negative integerÂ `x`, returnÂ *the square root of*Â `x`Â *rounded down to the nearest integer*. The returned integer should beÂ **non-negative**Â as well.

YouÂ **must not use**Â any built-in exponent function or operator.

- For example, do not useÂ `pow(x, 0.5)`Â in c++ orÂ `x ** 0.5`Â in python.

**Example 1:**

```
Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.

```

**Example 2:**

```
Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
```

</aside>

<aside>
ğŸ’¡ **Question 2**

A peak element is an element that is strictly greater than its neighbors.

Given aÂ **0-indexed**Â integer arrayÂ `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index toÂ **any of the peaks**.

You may imagine thatÂ `nums[-1] = nums[n] = -âˆ`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs inÂ `O(log n)`Â time.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```

**Example 2:**

```
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

</aside>

<aside>
ğŸ’¡ **Question 3**

****

Given an arrayÂ `nums`Â containingÂ `n`Â distinct numbers in the rangeÂ `[0, n]`, returnÂ *the only number in the range that is missing from the array.*

**Example 1:**

```
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

```

**Example 2:**

```
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

```

**Example 3:**

```
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
```

</aside>

<aside>
ğŸ’¡ **Question 4**

Given an array of integersÂ `nums`Â containingÂ `n + 1`Â integers where each integer is in the rangeÂ `[1, n]`Â inclusive.

There is onlyÂ **one repeated number**Â inÂ `nums`, returnÂ *thisÂ repeatedÂ number*.

You must solve the problemÂ **without**Â modifying the arrayÂ `nums`Â and uses only constant extra space.

**Example 1:**

```
Input: nums = [1,3,4,2,2]
Output: 2

```

**Example 2:**

```
Input: nums = [3,1,3,4,2]
Output: 3
```

</aside>

<aside>
ğŸ’¡ **Question 5**

Given two integer arraysÂ `nums1`Â andÂ `nums2`, returnÂ *an array of their intersection*. Each element in the result must beÂ **unique**Â and you may return the result inÂ **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
```

</aside>

<aside>
ğŸ’¡ **Question 6**

Suppose an array of lengthÂ `n`Â sorted in ascending order isÂ **rotated**Â betweenÂ `1`Â andÂ `n`Â times. For example, the arrayÂ `nums = [0,1,2,4,5,6,7]`Â might become:

- `[4,5,6,7,0,1,2]`Â if it was rotatedÂ `4`Â times.
- `[0,1,2,4,5,6,7]`Â if it was rotatedÂ `7`Â times.

Notice thatÂ **rotating**Â an arrayÂ `[a[0], a[1], a[2], ..., a[n-1]]`Â 1 time results in the arrayÂ `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated arrayÂ `nums`Â ofÂ **unique**Â elements, returnÂ *the minimum element of this array*.

You must write an algorithm that runs inÂ `O(log n) time.`

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.

```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.

```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times.
```

</aside>

<aside>
ğŸ’¡ **Question 7**

Given an array of integersÂ `nums`Â sorted in non-decreasing order, find the starting and ending position of a givenÂ `target`Â value.

IfÂ `target`Â is not found in the array, returnÂ `[-1, -1]`.

You mustÂ write an algorithm withÂ `O(log n)`Â runtime complexity.

**Example 1:**

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

```

**Example 2:**

```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

```

**Example 3:**

```
Input: nums = [], target = 0
Output: [-1,-1]
```

</aside>

<aside>
ğŸ’¡ **Question 8**

Given two integer arraysÂ `nums1`Â andÂ `nums2`, returnÂ *an array of their intersection*. Each element in the result must appear as many times as it shows in both arrays and you may return the result inÂ **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]

```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
```

</aside>
